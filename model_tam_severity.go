/*
Cisco Intersight

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.11-17412
Contact: intersight@cisco.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package intersight

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
)

// checks if the TamSeverity type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &TamSeverity{}

// TamSeverity < Severity associated with the advisory. Severity assignment and interpretation is specific to each type of advisory. Each advisory type (SecurityAdvisory etc.) is supposed to extend and implement Severity type based on the advisory type requirements.
type TamSeverity struct {
	MoBaseComplexType
	AdditionalProperties map[string]interface{}
}

type _TamSeverity TamSeverity

// NewTamSeverity instantiates a new TamSeverity object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewTamSeverity(classId string, objectType string) *TamSeverity {
	this := TamSeverity{}
	this.ClassId = classId
	this.ObjectType = objectType
	return &this
}

// NewTamSeverityWithDefaults instantiates a new TamSeverity object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewTamSeverityWithDefaults() *TamSeverity {
	this := TamSeverity{}
	return &this
}

func (o TamSeverity) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o TamSeverity) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	serializedMoBaseComplexType, errMoBaseComplexType := json.Marshal(o.MoBaseComplexType)
	if errMoBaseComplexType != nil {
		return map[string]interface{}{}, errMoBaseComplexType
	}
	errMoBaseComplexType = json.Unmarshal([]byte(serializedMoBaseComplexType), &toSerialize)
	if errMoBaseComplexType != nil {
		return map[string]interface{}{}, errMoBaseComplexType
	}

	for key, value := range o.AdditionalProperties {
		toSerialize[key] = value
	}

	return toSerialize, nil
}

func (o *TamSeverity) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"ClassId",
		"ObjectType",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err
	}

	for _, requiredProperty := range requiredProperties {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	type TamSeverityWithoutEmbeddedStruct struct {
	}

	varTamSeverityWithoutEmbeddedStruct := TamSeverityWithoutEmbeddedStruct{}

	err = json.Unmarshal(data, &varTamSeverityWithoutEmbeddedStruct)
	if err == nil {
		varTamSeverity := _TamSeverity{}
		*o = TamSeverity(varTamSeverity)
	} else {
		return err
	}

	varTamSeverity := _TamSeverity{}

	err = json.Unmarshal(data, &varTamSeverity)
	if err == nil {
		o.MoBaseComplexType = varTamSeverity.MoBaseComplexType
	} else {
		return err
	}

	additionalProperties := make(map[string]interface{})

	if err = json.Unmarshal(data, &additionalProperties); err == nil {

		// remove fields from embedded structs
		reflectMoBaseComplexType := reflect.ValueOf(o.MoBaseComplexType)
		for i := 0; i < reflectMoBaseComplexType.Type().NumField(); i++ {
			t := reflectMoBaseComplexType.Type().Field(i)

			if jsonTag := t.Tag.Get("json"); jsonTag != "" {
				fieldName := ""
				if commaIdx := strings.Index(jsonTag, ","); commaIdx > 0 {
					fieldName = jsonTag[:commaIdx]
				} else {
					fieldName = jsonTag
				}
				if fieldName != "AdditionalProperties" {
					delete(additionalProperties, fieldName)
				}
			}
		}

		o.AdditionalProperties = additionalProperties
	}

	return err
}

type NullableTamSeverity struct {
	value *TamSeverity
	isSet bool
}

func (v NullableTamSeverity) Get() *TamSeverity {
	return v.value
}

func (v *NullableTamSeverity) Set(val *TamSeverity) {
	v.value = val
	v.isSet = true
}

func (v NullableTamSeverity) IsSet() bool {
	return v.isSet
}

func (v *NullableTamSeverity) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTamSeverity(val *TamSeverity) *NullableTamSeverity {
	return &NullableTamSeverity{value: val, isSet: true}
}

func (v NullableTamSeverity) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTamSeverity) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
